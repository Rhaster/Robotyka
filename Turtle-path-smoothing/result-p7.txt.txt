from turtle import *
import ColabTurtle
import math
import random

TURTLE_SIZE = 10

#inicjacja przestrzeni do rysowania,
drawing_area = Screen()
setworldcoordinates(0, 0, 1200,
                    1000)  #ustawienie wspolrzeędnej pixelowej dolej i górnej,

speed(1)  #szybkosc rysowania od 1 do 10,
factor = 150  #liczba pixeli na jednostkę,
iter_number = 10  # liczba iteracji wygladzania

turtle1 = Turtle()  #definicja agenta,

hideturtle()  #make the turtle invisible
penup()

#generacja losowych punktów trasy
liczba_punktow = 12
x = []
y = []
x.append(.5)
y.append(4.5)
temp_x = x[0]
temp_y = y[0]
a = 0
#przykladowe rysowanie prostokatnej przeszkody:
#lewa górna współrzędna przeszkody
left_top_corner_x = 3
left_top_corner_y = 5
obstacle_width = 1
#szerokosc przeszkody
obstacle_height = 3
#wysokosc przeszkody
turtle1.hideturtle()  #ukrycie ikony agenta,
turtle1.penup()  #wylaczenie rysowania
turtle1.setx(left_top_corner_x * factor)
turtle1.sety(left_top_corner_y * factor)
turtle1.showturtle()  #odkrycie ikony agenta
turtle1.pendown()  #wlaczenie rysowania
#rysownie wypelnionego kolorem niebieskim prostokata,
turtle1.fillcolor('green')
turtle1.begin_fill()
turtle1.setheading(
  0)  #ustawiamy poczatkowy kierunek na polnoc, pólnoc jest skierowna w prawo,
turtle1.forward(obstacle_width * factor)
turtle1.right(90)
turtle1.forward(obstacle_height * factor)
turtle1.right(90)
turtle1.forward(obstacle_width * factor)
turtle1.right(90)
turtle1.forward(obstacle_height * factor)
turtle1.right(90)
turtle1.end_fill()

## sprawdzenie poprawnosci

x = [.5, 1.5, 2.5, 2.5, 2.5, 2.5, 3.5, 4.5, 5.5, 5.5, 5.5, 6.5]
y = [4.5, 4.5, 4.5, 3.5, 2.5, 1.5, 1.5, 1.5, 1.5, 2.5, 3.5, 3.5]
#path smoothing
print(len(x), len(y), liczba_punktow)
x0 = x
y0 = y

alpha = .2
beta = .2


def iteracja():
  for i0 in range(0, iter_number):
    for i in range(1, 11):
      holderx = x[i]
      holdery = y[i]
      x[i] = x[i] + alpha * (x0[i - 1] + x0[i + 1] - 2 * x[i])
      y[i] = y[i] + alpha * (y0[i - 1] + y0[i + 1] - 2 * y[i])
      x[i] = x[i] + beta * (x0[i] - x[i])
      y[i] = y[i] + beta * (y0[i] - y[i])
      if (x[i] > 3 and y[i] > 2 and x[i] < 4 and y[i] < 5):
        x[i] = holderx
        y[i] = holdery
        break
      if (((abs(x[i] - holderx) < 0.001)) and ((abs(y[i] - holdery) < 0.001))
          and holderx != x[i] and holdery != y[i]):
        return


#the end of path smoothing
iteracja()

setx(x[0] * factor)
sety(y[0] * factor)
dot(20, "blue")

print(distance(x[1] * factor, y[1] * factor))

angle = math.atan2(y[1] * factor - y[0] * factor,
                   x[1] * factor - x[0] * factor) * 180 / 3.14
setheading(angle)

showturtle()  #make the turtle visible
pendown()

#rysowanie trasy przez punkty sciezki
for i in range(1, liczba_punktow):
  #ustalanie kierunku agenta do kolejnego punktu sciezki,
  angle = math.atan2(y[i] * factor - y[i - 1] * factor,
                     x[i] * factor - x[i - 1] * factor) * 180 / 3.14
  setheading(angle)
  forward(distance(x[i] * factor, y[i] * factor))
  dot(10, "blue")
  if i == liczba_punktow - 1:
    dot(20, "green")
